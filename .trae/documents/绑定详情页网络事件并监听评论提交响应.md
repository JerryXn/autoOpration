## 目标
- 在进入笔记详情页后，立即绑定页面的网络事件：`request` 和 `response`
- 过滤并只记录 API 请求，重点监听评论提交接口：`https://edith.xiaohongshu.com/api/sns/web/v1/comment/post`
- 点击“发送”后，阻塞等待该接口的响应，解析并返回状态与 JSON，用于入库与成功判定

## 实现要点
- 事件绑定：在 `BrowserOperator.reply_to_comment()` 中，`self.goto(url)` 之后注册监听
- 过滤条件：仅处理 `'/api' in url` 的请求；忽略消息列表相关接口；只对 `edith.xiaohongshu.com` 且包含 `'/comment/post'` 的 URL 做捕获
- 阻塞等待：通过 `asyncio.Future` 承接一次性的“评论提交响应”；点击发送后 `wait_for` 该 future，拿到响应数据
- 日志规范：输出中文结构化日志，类别为 `远程调用`，级别 `begin/end/info/error`，包含 URL、方法、入参、状态、返回；与现有 Electron 彩色日志映射一致
- 清理：收到响应后，移除监听，避免内存泄露；若 `off` 不可用则用开关变量“enabled”停止处理
- 兼容：响应 JSON 解析失败时回退到 `text` 并尝试 `json.loads`；`post_data_json()` 解析失败回退到 `post_data`

## 代码改动（核心片段）
- 在 `src/automation/core/operator.py` 的 `reply_to_comment()` 中加入：

```python
loop = asyncio.get_event_loop()
page = self.browser._page
enabled = True
future_comment_post = loop.create_future()

TARGET_HOST = "edith.xiaohongshu.com"

def _is_comment_post(url: str) -> bool:
    u = str(url or '')
    return (TARGET_HOST in u) and ('/comment/post' in u)

last_req = {"url": None, "method": None, "body": None}

def on_request(req):
    if (not enabled) or ('/api' not in req.url):
        return
    if 'conversation/message/list' in req.url:
        return
    if _is_comment_post(req.url):
        body = None
        try:
            body = req.post_data_json()
        except Exception:
            try:
                body = json.loads(req.post_data or '')
            except Exception:
                body = None
        last_req.update({"url": req.url, "method": req.method, "body": body})
        print(json.dumps({
            "类别": "远程调用", "阶段": "请求", "动作": "评论提交",
            "说明": "发送评论请求", "入参": {"url": req.url, "method": req.method, "json": body},
            "状态": "begin"
        }, ensure_ascii=False))

async def _parse_response(res):
    status = res.status
    txt = ''
    try:
        txt = await res.text()
    except Exception:
        txt = ''
    j = None
    try:
        j = await res.json()
    except Exception:
        try:
            j = json.loads(txt or 'null')
        except Exception:
            j = None
    return {"status": status, "json": j, "text": txt}

def on_response(res):
    if (not enabled) or ('/api' not in res.url):
        return
    if 'conversation/message/list' in res.url:
        return
    if _is_comment_post(res.url):
        data = loop.run_until_complete(_parse_response(res))
        print(json.dumps({
            "类别": "远程调用", "阶段": "响应", "动作": "评论提交",
            "说明": "收到评论提交响应", "返回": {"status": data["status"]},
            "状态": "end"
        }, ensure_ascii=False))
        if not future_comment_post.done():
            future_comment_post.set_result(data)

page.on('request', on_request)
page.on('response', on_response)
```

- 在点击“发送”按钮后，等待响应：

```python
loop.run_until_complete(send_btn.click())
try:
    result = loop.run_until_complete(asyncio.wait_for(future_comment_post, timeout_ms / 1000.0))
    return result
except Exception:
    return {"status": 0, "json": None, "text": "publish_timeout"}
finally:
    enabled = False
    try:
        page.off('request', on_request)
        page.off('response', on_response)
    except Exception:
        pass
```

## 与现有流程衔接
- `comment_pipeline.process_note_comments()` 保持不变：仍以 `reply_to_comment()` 的返回进行成功判定：`status==200` 或 `code==0` 或 `success==true`
- 若解析到响应 JSON，则继续调用 `store_comment_reply_response()` 入库完整响应体

## 验证步骤
1. 启动浏览器并进入某条笔记详情页，事件监听应立即生效
2. 点击“回复/发送”后，日志出现两条：`[远程调用] 请求 begin`、`[远程调用] 响应 end`
3. 数据库 `op_comment_replies` 与 `op_comment_reply_responses` 写入记录；状态为成功或失败，响应体可查

## 可能的变体
- 若服务端切换到 `v2` 路径，匹配规则仍能工作（`'/comment/post'`）
- 如 `off` 不可用，则保留监听但用 `enabled=False` 停止处理
- 如响应多次触发，仅记录第一次并忽略后续