## 目标
- 访问并封装多个文档 ID 的接口，统一输出数据结构：`{name, url, heat, time}`。
- 复用 `.env` 的 `ITAPI_KEY`，对每个 docId 配置对应端点；并提供规范化适配器。

## 接口来源
- 文档地址（示例）：
  - 85 小红书热点：字段包含 `rank/name/date/viewnum/url`，GET
  - 83 综合新闻：最近新闻，GET
  - 75 7x24 热点报道：热文流，GET
  - 60 360热搜：热搜榜，GET
  - 61、62、15、18、13、14、17、58、63：按同站规则，GET（具体端点路径通过配置）

## 统一数据类型
- TrendItem：
  - `name` 字段：热点或标题
  - `url` 字段：详情或跳转链接
  - `heat` 字段：热度/访问量（文本或数值；优先数值，无法解析保留原文）
  - `time` 字段：时间字符串（如 `2024-06-06`、`2小时前`）
  - 可选：`source`（来源标识）、`rank`（排名）

## 适配与规范化
- 适配器注册表：`docId → normalizer(json) → [TrendItem]`
- 字段映射策略：
  - 85（小红书热点）：`name=json.name`、`url=json.url`、`heat=parseViewnum(json.viewnum)`、`time=json.date`、`rank=json.rank`
  - 60（360热搜）：尝试 `title/name`、`url/link`、`hot/index/heat`、`date/publish_time`
  - 83、75 等：同样通过常见键优先映射（`title/name`, `url/link`, `pv/hot/heat/viewnum`, `date/publish_time`）
- `parseViewnum`：将 `1100.9w` 转为数值（`w→*10^4`），其他单位保留文本作为回退
- 适配器允许保留原始项以应对字段差异；无法解析时返回空数组并记录错误

## 调用与合并
- 封装客户端：
  - `call_by_doc(docId, params)`：根据配置的端点路径执行 GET 请求，带 `key`
  - 执行后通过 `normalizer(docId)` 产出 `TrendItem[]`
- 聚合器：
  - `fetch_all(docIds)` 并发拉取（限速），合并为统一列表
  - 去重规则：按 `url` 或 `name` 归一（大小写与空白清洗），保留最高 `heat`

## 配置
- `.env`：
  - `ITAPI_KEY=<你的密钥>`
  - `ITAPI_ENDPOINT_85=hotnews/xiaohongshu`（已内置，也可覆盖）
  - 其余：`ITAPI_ENDPOINT_83=...`、`ITAPI_ENDPOINT_75=...`、`ITAPI_ENDPOINT_60=...`、`ITAPI_ENDPOINT_61=...`、`ITAPI_ENDPOINT_62=...`、`ITAPI_ENDPOINT_15=...`、`ITAPI_ENDPOINT_18=...`、`ITAPI_ENDPOINT_13=...`、`ITAPI_ENDPOINT_14=...`、`ITAPI_ENDPOINT_17=...`、`ITAPI_ENDPOINT_58=...`、`ITAPI_ENDPOINT_63=...`
- 若端点缺失：返回 `endpoint_missing` 并跳过该源

## 错误处理与限流
- 超时与错误：JSON 解析失败时返回原始文本；网络错误记录并跳过该源
- 并发控制：每秒请求数限速（例如 5/s），避免触发站点限制

## 交付
- 在现有 `itapi_client.py` 基础上新增：
  - docId→端点映射与 normalizer 注册
  - `fetch_all(docIds)` 返回统一 `TrendItem[]`
- 提供单元测试样例：针对 85 的示例响应做字段映射校验

请确认，确认后我将实现适配器与聚合器，并在仓库内添加使用示例（读取 `.env`，调用各 docId 并输出统一列表）。